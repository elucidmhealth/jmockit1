/*
 * Copyright (c) 2006 Rog√©rio Liesenfeld
 * This file is subject to the terms of the MIT license (see LICENSE.txt).
 */
package mockit.internal.faking;

import java.lang.reflect.*;
import javax.annotation.*;

import mockit.internal.*;
import mockit.internal.state.*;
import static mockit.internal.util.Utilities.*;

/**
 * An invocation to a {@code @Mock} method.
 */
public final class MockInvocation extends BaseInvocation
{
   @Nonnull private final FakeState fakeState;
   @Nonnull private final String mockedClassDesc;
   @Nonnull private final String mockedMethodName;
   @Nonnull private final String mockedMethodDesc;
   boolean proceeding;

   @Nonnull // called by generated bytecode
   public static MockInvocation create(
      @Nullable Object invokedInstance, @Nullable Object[] invokedArguments,
      @Nonnull String mockClassDesc, int mockStateIndex,
      @Nonnull String mockedClassDesc, @Nonnull String mockedMethodName, @Nonnull String mockedMethodDesc)
   {
      Object mockUp = TestRun.getFake(mockClassDesc, invokedInstance);
      FakeState fakeState = TestRun.getFakeStates().getFakeState(mockUp, mockStateIndex);
      Object[] args = invokedArguments == null ? NO_ARGS : invokedArguments;
      return new MockInvocation(invokedInstance, args, fakeState, mockedClassDesc, mockedMethodName, mockedMethodDesc);
   }

   MockInvocation(
      @Nullable Object invokedInstance, @Nonnull Object[] invokedArguments, @Nonnull FakeState fakeState,
      @Nonnull String mockedClassDesc, @Nonnull String mockedMethodName, @Nonnull String mockedMethodDesc)
   {
      super(invokedInstance, invokedArguments, fakeState.getTimesInvoked());
      this.fakeState = fakeState;
      this.mockedClassDesc = mockedClassDesc;
      this.mockedMethodName = mockedMethodName;
      this.mockedMethodDesc = mockedMethodDesc;
   }

   @Nonnull @Override
   protected Member findRealMember()
   {
      Object invokedInstance = getInvokedInstance();

      if (invokedInstance != null) {
         Class<?> mockedClass = invokedInstance.getClass();
         return fakeState.getRealMethodOrConstructor(mockedClass, mockedMethodName, mockedMethodDesc);
      }

      return fakeState.getRealMethodOrConstructor(mockedClassDesc, mockedMethodName, mockedMethodDesc);
   }

   boolean shouldProceedIntoConstructor()
   {
      if (proceeding && getInvokedMember() instanceof Constructor) {
         fakeState.clearProceedIndicator();
         return true;
      }

      return false;
   }

   @Override
   public void prepareToProceed()
   {
      fakeState.prepareToProceed(this);
      proceeding = true;
   }

   public void prepareToProceedFromNonRecursiveMock()
   {
      fakeState.prepareToProceedFromNonRecursiveFake(this);
      proceeding = true;
   }

   @Override
   public void cleanUpAfterProceed()
   {
      fakeState.clearProceedIndicator();
   }
}
